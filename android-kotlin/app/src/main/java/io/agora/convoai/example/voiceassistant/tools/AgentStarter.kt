package io.agora.convoai.example.voiceassistant.tools

import io.agora.convoai.example.voiceassistant.KeyCenter
import io.agora.convoai.example.voiceassistant.net.SecureOkHttpClient
import kotlinx.coroutines.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONObject

/**
 * Agent Starter
 * Unified interface for starting/stopping agents
 * Only the base URL differs between local server and Agora API
 */
object AgentStarter {
    private const val JSON_MEDIA_TYPE = "application/json; charset=utf-8"
    // Switch between local server and Agora API by commenting/uncommenting the lines below
    private const val AGORA_API_BASE_URL = "https://api.sd-rtn.com/cn/api/conversational-ai-agent/v2/projects"
//    private const val AGORA_API_BASE_URL = "http://10.103.1.61:8080"  // Local server (for development)
    private const val DEFAULT_AGENT_RTC_UID = "1009527"

    private val okHttpClient: OkHttpClient by lazy {
        SecureOkHttpClient.create()
            .build()
    }

    /**
     * Start an agent
     * Unified interface: same format for both local server and Agora API
     *
     * @param channelName Channel name for the agent
     * @param agentRtcUid Agent RTC UID (optional, defaults to "1009527")
     * @param token Agent token (required, should be generated by client)
     * @return Result containing agentId or exception
     */
    suspend fun startAgentAsync(
        channelName: String,
        agentRtcUid: String = DEFAULT_AGENT_RTC_UID,
        token: String
    ): Result<String> = withContext(Dispatchers.IO) {
        try {
            val projectId = KeyCenter.AGORA_APP_ID
            val url = "$AGORA_API_BASE_URL/$projectId/join/"

            val requestBody = buildJsonPayload(
                name = channelName,
                pipelineId = KeyCenter.PIPELINE_ID,
                channel = channelName,
                agentRtcUid = agentRtcUid,
                token = token,
                remoteRtcUids = listOf("*")
            )

            val requestBuilder = Request.Builder()
                .url(url)
                .addHeader("Content-Type", JSON_MEDIA_TYPE)
                .post(requestBody.toString().toRequestBody(JSON_MEDIA_TYPE.toMediaType()))

            // Add Authorization header
            val authorization = Base64Encoding.gen(KeyCenter.REST_KEY, KeyCenter.REST_SECRET)
            requestBuilder.addHeader("Authorization", authorization)

            val request = requestBuilder.build()
            val response = okHttpClient.newCall(request).execute()

            if (!response.isSuccessful) {
                val errorBody = response.body?.string() ?: response.message
                throw RuntimeException("Start agent error: httpCode=${response.code}, httpMsg=$errorBody")
            }

            val body = response.body?.string() ?: throw RuntimeException("Response body is null")
            val bodyJson = JSONObject(body)

            // Unified response format: {"agent_id": "..."}
            val agentId = bodyJson.optString("agent_id", "")

            if (agentId.isBlank()) {
                throw RuntimeException("Failed to parse agentId from response: $body")
            }

            Result.success(agentId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Build JSON payload for Agora API
     */
    private fun buildJsonPayload(
        name: String,
        pipelineId: String,
        channel: String,
        agentRtcUid: String,
        token: String,
        remoteRtcUids: List<String>
    ): JSONObject {
        val payloadMap = mapOf(
            "name" to name,
            "pipeline_id" to pipelineId,
            "properties" to mapOf(
                "channel" to channel,
                "agent_rtc_uid" to agentRtcUid,
                "remote_rtc_uids" to remoteRtcUids,
                "token" to token
            )
        )
        return mapToJsonObjectWithFilter(payloadMap)
    }

    /**
     * Convert Map to JSONObject, filtering out null values
     */
    private fun mapToJsonObjectWithFilter(map: Map<String, Any?>): JSONObject {
        val jsonObject = JSONObject()
        map.forEach { (key, value) ->
            when {
                value == null -> {
                    // Skip null values
                }

                value is Map<*, *> -> {
                    // Handle nested Map
                    @Suppress("UNCHECKED_CAST")
                    val nestedJsonObject = mapToJsonObjectWithFilter(value as Map<String, Any?>)
                    if (nestedJsonObject.length() > 0) {
                        jsonObject.put(key, nestedJsonObject)
                    }
                }

                value is List<*> -> {
                    // Handle List type
                    val jsonArray = JSONArray()
                    value.forEach { item ->
                        when {
                            item == null -> {
                                // Skip null values
                            }

                            item is Map<*, *> -> {
                                // Handle Map in List
                                @Suppress("UNCHECKED_CAST")
                                jsonArray.put(mapToJsonObjectWithFilter(item as Map<String, Any?>))
                            }

                            else -> {
                                jsonArray.put(item)
                            }
                        }
                    }
                    if (jsonArray.length() > 0) {
                        jsonObject.put(key, jsonArray)
                    }
                }

                else -> {
                    // Handle basic types
                    jsonObject.put(key, value)
                }
            }
        }
        return jsonObject
    }

    /**
     * Stop an agent
     * Unified interface: same format for both local server and Agora API
     *
     * @param agentId Agent ID to stop
     * @return Result containing success or exception
     */
    suspend fun stopAgentAsync(
        agentId: String
    ): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val projectId = KeyCenter.AGORA_APP_ID
            val url = "$AGORA_API_BASE_URL/$projectId/agents/$agentId/leave"

            val requestBuilder = Request.Builder()
                .url(url)
                .post("".toRequestBody("application/json; charset=utf-8".toMediaType()))

            // Add Authorization header
            val authorization = Base64Encoding.gen(KeyCenter.REST_KEY, KeyCenter.REST_SECRET)
            requestBuilder.addHeader("Authorization", authorization)

            val request = requestBuilder.build()
            val response = okHttpClient.newCall(request).execute()

            if (!response.isSuccessful) {
                val errorBody = response.body?.string() ?: response.message
                throw RuntimeException("Stop agent error: httpCode=${response.code}, httpMsg=$errorBody")
            }

            // Unified response: just check status code
            response.body?.close()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Check if the server is available
     *
     * @return Result containing true if server is available, false otherwise
     */
    suspend fun checkServerHealth(): Result<Boolean> = withContext(Dispatchers.IO) {
        try {
            // Health check only works for local server
            // For Agora API, skip health check or use a different endpoint
            if (AGORA_API_BASE_URL.startsWith("http://")) {
                val url = "$AGORA_API_BASE_URL/health"
                val request = Request.Builder()
                    .url(url)
                    .get()
                    .build()
                val response = okHttpClient.newCall(request).execute()
                Result.success(response.isSuccessful)
            } else {
                // Agora API doesn't have a health endpoint, return success
                Result.success(true)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

